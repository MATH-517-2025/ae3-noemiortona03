# Parametri fissi
ALPHA <- 2
BETA <- 5
# Loop ESTERNO: itera su ogni valore di n
for (n_i in n_values) {
print(paste("Esecuzione di", N_REPLICATIONS, "repliche per n =", n_i))
# Vettori per salvare i risultati di ogni replica
n_opt_replicates <- numeric(N_REPLICATIONS)
h_amise_replicates <- numeric(N_REPLICATIONS) # Aggiunto vettore per h_amise
# Loop INTERNO: esegue la simulazione più volte per lo stesso n
for (rep in 1:N_REPLICATIONS) {
# 1. Genera i dati
sim_data <- generate_data(n = n_i, alpha = ALPHA, beta = BETA)
# 2. Trova N ottimale (usando la versione robusta di find_optimal_N)
N_opt <- find_optimal_N(sim_data)
# 3. Stima i parametri con N ottimale
params <- estimate_params(sim_data, N_opt)
# 4. Calcola h_AMISE per questa replica
h_amise <- (n_i^(-1/5)) * ( (35 * params$sigma_sq_hat) / params$theta_22_hat )^(1/5)
# Salva i risultati di questa specifica replica
n_opt_replicates[rep] <- N_opt
h_amise_replicates[rep] <- h_amise
}
# Calcola la media dei risultati per l'attuale n
average_n_opt <- mean(n_opt_replicates)
average_h_amise <- mean(h_amise_replicates) # Aggiunto calcolo media per h_amise
# Salva i risultati mediati
results_averaged <- rbind(results_averaged, data.frame(
n = n_i,
avg_N_opt = average_n_opt,
avg_h_amise = average_h_amise
))
}
# Grafico 1: N ottimale MEDIO vs n
plot_N_vs_n_averaged <- ggplot(results_averaged, aes(x = n, y = avg_N_opt)) +
geom_line(color="darkgreen", linewidth = 1.2) +
geom_point(color="darkgreen", size = 3) +
labs(title = "N ottimale MEDIO scelto al variare di n",
subtitle = paste("Basato su", N_REPLICATIONS, "repliche per ogni punto"),
x = "Dimensione del Campione (n)",
y = "Numero Medio di Blocchi Ottimale (N_opt)") +
theme_minimal()
print(plot_N_vs_n_averaged)
# Calcoliamo il tasso teorico n^(-1/5) per confronto
scale_factor <- results_averaged$avg_h_amise[1] / (results_averaged$n[1]^(-1/5))
# Grafico 1: N ottimale MEDIO vs n
plot_N_vs_n_averaged <- ggplot(results_averaged, aes(x = n, y = avg_N_opt)) +
geom_line(color="darkgreen", linewidth = 1.2) +
geom_point(color="darkgreen", size = 3) +
labs(title = "N ottimale MEDIO scelto al variare di n",
subtitle = paste("Basato su", N_REPLICATIONS, "repliche per ogni punto"),
x = "Dimensione del Campione (n)",
y = "Numero Medio di Blocchi Ottimale (N_opt)") +
theme_minimal()
print(plot_N_vs_n_averaged)
# Calcoliamo il tasso teorico n^(-1/5) per confronto
scale_factor <- results_averaged$avg_h_amise[1] / (results_averaged$n[1]^(-1/5))
results_averaged$theoretical_rate <- scale_factor * results_averaged$n^(-1/5)
plot_h_vs_n_averaged <- ggplot(results_averaged, aes(x = n)) +
geom_line(aes(y = avg_h_amise, color = "h_AMISE Medio Stimato"), linewidth = 1.2) +
geom_line(aes(y = theoretical_rate, color = "Tasso Teorico n^(-1/5)"), linetype = "dashed", linewidth = 1) +
labs(
title = "Comportamento di h_AMISE MEDIO al crescere di n",
subtitle = paste("Basato su", N_REPLICATIONS, "repliche per ogni punto"),
x = "Dimensione del Campione (n)",
y = "Larghezza di Banda Ottimale Media (h_AMISE)",
color = "Legenda"
) +
theme_minimal() +
scale_color_manual(values = c("h_AMISE Medio Stimato" = "blue", "Tasso Teorico n^(-1/5)" = "red"))
print(plot_h_vs_n_averaged)
# Parametri fissi
N_SIM_BETA <- 1000
# Configurazioni di (alpha, beta) da testare
beta_params <- data.frame(
alpha = c(1, 0.5, 5, 2),
beta = c(1, 0.5, 5, 8),
shape = c("Uniforme", "A U (bordi)", "Campana (centro)", "Asimmetrica (sx)")
)
results_beta <- data.frame()
# Loop sulle diverse forme della distribuzione
for (i in 1:nrow(beta_params)) {
a <- beta_params$alpha[i]
b <- beta_params$beta[i]
shape_desc <- beta_params$shape[i]
print(paste("Simulazione per Beta(a=", a, ", b=", b, ")"))
sim_data <- generate_data(n = N_SIM_BETA, alpha = a, beta = b)
N_opt <- find_optimal_N(sim_data)
params <- estimate_params(sim_data, N_opt)
h_amise <- (N_SIM_BETA^(-1/5)) * ( (35 * params$sigma_sq_hat) / params$theta_22_hat )^(1/5)
results_beta <- rbind(results_beta, data.frame(
alpha = a,
beta = b,
shape = shape_desc,
theta_22_hat = params$theta_22_hat,
h_amise = h_amise
))
}
# Grafico a barre per confrontare h_amise
plot_beta_impact <- ggplot(results_beta, aes(x = shape, y = h_amise, fill = shape)) +
geom_bar(stat = "identity") +
labs(
title = "Impatto della distribuzione di X su h_AMISE",
x = "Forma della Distribuzione Beta",
y = "Larghezza di Banda Ottimale (h_AMISE)"
) +
theme_minimal() +
theme(legend.position = "none")
print(plot_beta_impact)
# Visualizziamo la funzione e la sua curvatura (approssimata)
x_grid <- seq(0, 1, length.out = 500)
m_vals <- true_m(x_grid)
# Approssimiamo numericamente la seconda derivata
m_d2 <- diff(diff(m_vals))
# Normalizziamo per la visualizzazione
m_d2_scaled <- m_vals[1:(length(m_vals)-2)] + 0.1 * m_d2 / max(abs(m_d2))
plot_data_func <- data.frame(x = x_grid, y = m_vals)
plot_data_curv <- data.frame(x = x_grid[1:(length(m_d2_scaled))], y = m_d2_scaled)
ggplot(plot_data_func, aes(x = x, y = y)) +
geom_line(aes(color = "Funzione m(x)"), linewidth = 1.2) +
geom_line(data = plot_data_curv, aes(x = x, y = y, color = "Curvatura Riscalata"), linetype = "dashed", linewidth = 1) +
labs(
title = "Funzione m(x) e la sua Curvatura (corretto)",
x = "x",
y = "Valore",
color = "Legenda"
) +
scale_color_manual(values = c("Funzione m(x)" = "blue", "Curvatura Riscalata" = "red")) +
theme_minimal()
rm(list=ls())
library(ggplot2)
library(dplyr)
library(tidyr)
library(gridExtra)
# Set seed for reproducibility
set.seed(953)
# Define the true regression function m(x)
true_m <- function(x) {
sin(1 / (x / 3 + 0.1))
}
#Function to generate data
# Generates n samples from Y = m(X) + epsilon, with X ~ Beta(alpha, beta) and epsilon ~ N(0, sigma_sq)
generate_data <- function(n, alpha, beta, sigma_sq = 1) {
# Generate the covariate X from a Beta distribution
x <- rbeta(n, shape1 = alpha, shape2 = beta)
# Generate the error epsilon from a Normal distribution
epsilon <- rnorm(n, mean = 0, sd = sqrt(sigma_sq))
# Calculate the response Y
y <- true_m(x) + epsilon
# Return the data as a dataframe
return(data.frame(x = x, y = y))
}
# Function to estimate sigma^2 and theta_22 for a given number of blocks N
estimate_params <- function(data, N) {
n <- nrow(data)
if (N == 1) {
# Se c'è un solo blocco, adatta il modello all'intero dataset
fit <- lm(y ~ poly(x, 4, raw = TRUE), data = data)
# Estrae il coefficiente beta_2
beta_2_hat <- ifelse(is.na(coef(fit)[3]), 0, coef(fit)[3])
# Calcola m''^2 e i residui^2 per tutti i punti
m_double_prime_sq <- rep((2 * beta_2_hat)^2, n)
residuals_sq <- residuals(fit)^2
}else{
data <- data[order(data$x), ] # Sort the data by x to create the blocks
# Divide the data indices into N blocks of similar sizes
block_indices <- cut(1:n, breaks = N, labels = FALSE)
# Initialize vectors to store the results
residuals_sq <- numeric(n)
m_double_prime_sq <- numeric(n)
# Iterate over each block
for (j in 1:N) {
block_data <- data[block_indices == j, ]
# If the block is too small to fit the model, skip it
if (nrow(block_data) < 5) next
# Fit a 4th-degree polynomial model
# we use poly(..., raw=TRUE) to get the direct coefficients (beta_0, beta_1, ...)
fit <- lm(y ~ poly(x, 4, raw = TRUE), data = block_data)
# Extract the beta_2 coefficient. The estimated second derivative is 2 * beta_2
beta_2_hat <- coef(fit)[3]
# Save the square of the second derivative for the points in this block
# m_hat''(x) = 2 * beta_2_hat
m_double_prime_sq[block_indices == j] <- (2 * beta_2_hat)^2
# Save the squared residuals
residuals_sq[block_indices == j] <- residuals(fit)^2
}
}
# Calculate the estimate of sigma^2(N)
# RSS(N) = sum(residuals_sq)
# Degrees of freedom: n - 5*N (5 parameters for N models)
sigma_sq_hat <- sum(residuals_sq) / (n - 5 * N)
# Calculate the estimate of theta_22(N)
theta_22_hat <- mean(m_double_prime_sq)
return(list(
sigma_sq_hat = sigma_sq_hat,
theta_22_hat = theta_22_hat,
RSS = sum(residuals_sq)
))
}
# Function to find the optimal number of blocks N
find_optimal_N <- function(data, min_block_size = 20) { # Aggiunto parametro per la stabilità
n <- nrow(data)
N_max <- max(min(floor(n / 20), 5), 1)
if (N_max == 1) return(1)
# Calcola la stima della varianza dal modello più complesso (se stabile)
if (n / N_max < min_block_size) {
# Se anche il modello N_max è instabile, riduci N_max a un valore sicuro
N_max <- floor(n / min_block_size)
if (N_max < 1) return(1) # Se n è troppo piccolo anche per un blocco, restituisci 1
}
est_full_model <- estimate_params(data, N_max)
sigma_sq_hat_full <- est_full_model$RSS / (n - 5 * N_max)
if (sigma_sq_hat_full <= 0) {
sigma_sq_hat_full <- 1e-9
}
cp_values <- numeric(N_max)
for (N in 1:N_max) {
# CONTROLLO DI STABILITÀ: ignora N se i blocchi sono troppo piccoli
if (n / N < min_block_size) {
cp_values[N] <- Inf # Assegna un valore infinito per scartare questa opzione
next # Passa al prossimo valore di N
}
if (N == N_max) {
rss_current <- est_full_model$RSS
} else {
est_current <- estimate_params(data, N)
rss_current <- est_current$RSS
}
# Usa la formula corretta del paper
cp_values[N] <- rss_current / sigma_sq_hat_full - (n - 10 * N)
}
if (all(is.infinite(cp_values))) return(1)
# Restituisce l'N che minimizza Cp
return(which.min(cp_values))
}
# Vettore delle dimensioni del campione da testare
n_values <- seq(200, 3000, by = 200)
# Numero di repliche per ogni n per mediare la casualità
N_REPLICATIONS <- 200
# Dataframe finale per salvare i risultati mediati
results_averaged <- data.frame()
# Parametri fissi
ALPHA <- 2
BETA <- 5
# Loop ESTERNO: itera su ogni valore di n
for (n_i in n_values) {
print(paste("Esecuzione di", N_REPLICATIONS, "repliche per n =", n_i))
# Vettori per salvare i risultati di ogni replica
n_opt_replicates <- numeric(N_REPLICATIONS)
h_amise_replicates <- numeric(N_REPLICATIONS) # Aggiunto vettore per h_amise
# Loop INTERNO: esegue la simulazione più volte per lo stesso n
for (rep in 1:N_REPLICATIONS) {
# 1. Genera i dati
sim_data <- generate_data(n = n_i, alpha = ALPHA, beta = BETA)
# 2. Trova N ottimale (usando la versione robusta di find_optimal_N)
N_opt <- find_optimal_N(sim_data)
# 3. Stima i parametri con N ottimale
params <- estimate_params(sim_data, N_opt)
# 4. Calcola h_AMISE per questa replica
h_amise <- (n_i^(-1/5)) * ( (35 * params$sigma_sq_hat) / params$theta_22_hat )^(1/5)
# Salva i risultati di questa specifica replica
n_opt_replicates[rep] <- N_opt
h_amise_replicates[rep] <- h_amise
}
# Calcola la media dei risultati per l'attuale n
average_n_opt <- mean(n_opt_replicates)
average_h_amise <- mean(h_amise_replicates) # Aggiunto calcolo media per h_amise
# Salva i risultati mediati
results_averaged <- rbind(results_averaged, data.frame(
n = n_i,
avg_N_opt = average_n_opt,
avg_h_amise = average_h_amise
))
}
# Grafico 1: N ottimale MEDIO vs n
plot_N_vs_n_averaged <- ggplot(results_averaged, aes(x = n, y = avg_N_opt)) +
geom_line(color="darkgreen", linewidth = 1.2) +
geom_point(color="darkgreen", size = 3) +
labs(title = "N ottimale MEDIO scelto al variare di n",
subtitle = paste("Basato su", N_REPLICATIONS, "repliche per ogni punto"),
x = "Dimensione del Campione (n)",
y = "Numero Medio di Blocchi Ottimale (N_opt)") +
theme_minimal()
print(plot_N_vs_n_averaged)
# Calcoliamo il tasso teorico n^(-1/5) per confronto
scale_factor <- results_averaged$avg_h_amise[1] / (results_averaged$n[1]^(-1/5))
results_averaged$theoretical_rate <- scale_factor * results_averaged$n^(-1/5)
plot_h_vs_n_averaged <- ggplot(results_averaged, aes(x = n)) +
geom_line(aes(y = avg_h_amise, color = "h_AMISE Medio Stimato"), linewidth = 1.2) +
geom_line(aes(y = theoretical_rate, color = "Tasso Teorico n^(-1/5)"), linetype = "dashed", linewidth = 1) +
labs(
title = "Comportamento di h_AMISE MEDIO al crescere di n",
subtitle = paste("Basato su", N_REPLICATIONS, "repliche per ogni punto"),
x = "Dimensione del Campione (n)",
y = "Larghezza di Banda Ottimale Media (h_AMISE)",
color = "Legenda"
) +
theme_minimal() +
scale_color_manual(values = c("h_AMISE Medio Stimato" = "blue", "Tasso Teorico n^(-1/5)" = "red"))
print(plot_h_vs_n_averaged)
# Parametri fissi
N_SIM_BETA <- 1000
# Configurazioni di (alpha, beta) da testare
beta_params <- data.frame(
alpha = c(1, 0.5, 5, 2),
beta = c(1, 0.5, 5, 8),
shape = c("Uniforme", "A U (bordi)", "Campana (centro)", "Asimmetrica (sx)")
)
results_beta <- data.frame()
# Loop sulle diverse forme della distribuzione
for (i in 1:nrow(beta_params)) {
a <- beta_params$alpha[i]
b <- beta_params$beta[i]
shape_desc <- beta_params$shape[i]
print(paste("Simulazione per Beta(a=", a, ", b=", b, ")"))
sim_data <- generate_data(n = N_SIM_BETA, alpha = a, beta = b)
N_opt <- find_optimal_N(sim_data)
params <- estimate_params(sim_data, N_opt)
h_amise <- (N_SIM_BETA^(-1/5)) * ( (35 * params$sigma_sq_hat) / params$theta_22_hat )^(1/5)
results_beta <- rbind(results_beta, data.frame(
alpha = a,
beta = b,
shape = shape_desc,
theta_22_hat = params$theta_22_hat,
h_amise = h_amise
))
}
# Grafico a barre per confrontare h_amise
plot_beta_impact <- ggplot(results_beta, aes(x = shape, y = h_amise, fill = shape)) +
geom_bar(stat = "identity") +
labs(
title = "Impatto della distribuzione di X su h_AMISE",
x = "Forma della Distribuzione Beta",
y = "Larghezza di Banda Ottimale (h_AMISE)"
) +
theme_minimal() +
theme(legend.position = "none")
print(plot_beta_impact)
# Crea una griglia di punti x
x_grid <- seq(0.01, 1, length.out = 500)
m_vals <- true_m(x_grid)
# Calcola la seconda derivata (curvatura) in modo numerico
m_d2 <- diff(diff(m_vals))
# Riscala la curvatura per poterla visualizzare
m_d2_scaled <- m_vals[1:(length(m_vals)-2)] + 0.1 * m_d2 / max(abs(m_d2))
# Prepara i dati per il grafico
plot_data_func <- data.frame(x = x_grid, y = m_vals)
plot_data_curv <- data.frame(x = x_grid[1:(length(m_d2_scaled))], y = m_d2_scaled)
# Disegna il grafico
ggplot(plot_data_func, aes(x = x, y = y)) +
geom_line(aes(color = "Funzione m(x)"), linewidth = 1.1) +
geom_line(data = plot_data_curv, aes(x = x, y = y, color = "Curvatura Riscalata"), linetype = "dashed", linewidth = 1.1) +
labs(
title = "Funzione m(x) e la sua Curvatura (corretto)",
x = "X",
y = "Valore",
color = "Legenda"
) +
scale_color_manual(values = c("Funzione m(x)" = "blue", "Curvatura Riscalata" = "red")) +
theme_minimal() +
theme(legend.position = "bottom")
rm(list=ls())
library(ggplot2)
# Definisci la funzione
true_m <- function(x) {
sin(1 / (x / 3 + 0.1))
}
# Crea una griglia di punti x
x_grid <- seq(0.01, 1, length.out = 500)
m_vals <- true_m(x_grid)
# Calcola la seconda derivata (curvatura) in modo numerico
m_d2 <- diff(diff(m_vals))
# Riscala la curvatura per poterla visualizzare
m_d2_scaled <- m_vals[1:(length(m_vals)-2)] + 0.1 * m_d2 / max(abs(m_d2))
# Prepara i dati per il grafico
plot_data_func <- data.frame(x = x_grid, y = m_vals)
plot_data_curv <- data.frame(x = x_grid[1:(length(m_d2_scaled))], y = m_d2_scaled)
# Disegna il grafico
ggplot(plot_data_func, aes(x = x, y = y)) +
geom_line(aes(color = "Funzione m(x)"), linewidth = 1.1) +
geom_line(data = plot_data_curv, aes(x = x, y = y, color = "Curvatura Riscalata"), linetype = "dashed", linewidth = 1.1) +
labs(
title = "Funzione m(x) e la sua Curvatura (corretto)",
x = "X",
y = "Valore",
color = "Legenda"
) +
scale_color_manual(values = c("Funzione m(x)" = "blue", "Curvatura Riscalata" = "red")) +
theme_minimal() +
theme(legend.position = "bottom")
head(plot_data_curv)
# --- Blocco di Codice Completo e Autonomo per il Grafico Finale ---
library(ggplot2)
# Definisci la funzione
true_m <- function(x) {
sin(1 / (x / 3 + 0.1))
}
# Crea una griglia di punti x
x_grid <- seq(0.01, 1, length.out = 500)
m_vals <- true_m(x_grid)
# Calcola la seconda derivata (curvatura) in modo numerico
m_d2 <- diff(diff(m_vals))
# Riscala la curvatura per poterla visualizzare
m_d2_scaled <- m_vals[1:(length(m_vals)-2)] + 0.1 * m_d2 / max(abs(m_d2))
# Prepara i dati per il grafico
plot_data_func <- data.frame(x = x_grid, y = m_vals)
plot_data_curv <- data.frame(x = x_grid[1:(length(m_d2_scaled))], y = m_d2_scaled)
# Disegna il grafico
ggplot(plot_data_func, aes(x = x, y = y)) +
geom_line(aes(color = "Funzione m(x)"), linewidth = 1.1) +
geom_line(data = plot_data_curv, aes(x = x, y = y, color = "Curvatura Riscalata"), linetype = "dashed", linewidth = 1.1) +
labs(
title = "Funzione m(x) e la sua Curvatura (corretto)",
x = "X",
y = "Valore",
color = "Legenda"
) +
scale_color_manual(values = c("Funzione m(x)" = "blue", "Curvatura Riscalata" = "red")) +
theme_minimal() +
theme(legend.position = "bottom")
# --- Blocco di Codice Completo e Autonomo per il Grafico Finale ---
library(ggplot2)
# Definisci la funzione
true_m <- function(x) {
sin(1 / (x / 3 + 0.1))
}
# Crea una griglia di punti x
x_grid <- seq(0.01, 1, length.out = 500)
m_vals <- true_m(x_grid)
# Calcola la seconda derivata (curvatura) in modo numerico
m_d2 <- diff(diff(m_vals))
# Riscala la curvatura per poterla visualizzare
m_d2_scaled <- m_vals[1:(length(m_vals)-2)] + 0.1 * m_d2 / max(abs(m_d2))
# Prepara i dati per il grafico
plot_data_func <- data.frame(x = x_grid, y = m_vals)
plot_data_curv <- data.frame(x = x_grid[1:(length(m_d2_scaled))], y = m_d2_scaled)
# Disegna il grafico
ggplot(plot_data_func, aes(x = x, y = y)) +
geom_line(aes(color = "Funzione m(x)"), linewidth = 1.1) +
geom_line(data = plot_data_curv, aes(x = x, y = y, color = "Curvatura Riscalata"), linetype = "dashed", linewidth = 1.1) +
labs(
title = "Funzione m(x) e la sua Curvatura (corretto)",
x = "X",
y = "Valore",
color = "Legenda"
) +
scale_color_manual(values = c("Funzione m(x)" = "blue", "Curvatura Riscalata" = "red")) +
theme_minimal() +
theme(legend.position = "bottom")
# --- Blocco di Codice Completo e Autonomo per il Grafico Finale ---
library(ggplot2)
# Definisci la funzione
true_m <- function(x) {
sin(1 / (x / 3 + 0.1))
}
# Crea una griglia di punti x
x_grid <- seq(0.01, 1, length.out = 500)
m_vals <- true_m(x_grid)
# Calcola la seconda derivata (curvatura) in modo numerico
m_d2 <- diff(diff(m_vals))
# Riscala la curvatura per poterla visualizzare
m_d2_scaled <- m_vals[1:(length(m_vals)-2)] + 0.1 * m_d2 / max(abs(m_d2))
# Prepara i dati per il grafico
plot_data_func <- data.frame(x = x_grid, y = m_vals)
plot_data_curv <- data.frame(x = x_grid[1:(length(m_d2_scaled))], y = m_d2_scaled)
# Disegna il grafico
ggplot(plot_data_func, aes(x = x, y = y)) +
geom_line(aes(color = "Funzione m(x)"), linewidth = 1.1) +
geom_line(data = plot_data_curv, aes(x = x, y = y, color = "Curvatura Riscalata"), linetype = "dashed", linewidth = 1.1) +
labs(
title = "Funzione m(x) e la sua Curvatura (corretto)",
x = "X",
y = "Valore",
color = "Legenda"
) +
scale_color_manual(values = c("Funzione m(x)" = "blue", "Curvatura Riscalata" = "red")) +
theme_minimal() +
theme(legend.position = "bottom")
# Riscala la curvatura per poterla visualizzare
m_d2_scaled <- m_vals[1:(length(m_vals)-2)] + 0.1 * m_d2 / max(abs(m_d2))
head(m_d2_scaled)
head(m_d2)
head(m_vals)
rm(list=ls())
library(ggplot2)
# Funzione m(x)
true_m_func <- function(x) {
sin(1 / (x / 3 + 0.1))
}
# 1. Creazione dati con nomi di variabili NUOVI
x_vector <- seq(0.01, 1, length.out = 500)
y_vector_func <- true_m_func(x_vector)
y_vector_curv_raw <- diff(diff(y_vector_func))
y_vector_curv_scaled <- y_vector_func[1:(length(y_vector_func)-2)] + 0.1 * y_vector_curv_raw / max(abs(y_vector_curv_raw))
# 2. Creazione dataframe con nomi NUOVI
data_for_func_plot <- data.frame(x = x_vector, y = y_vector_func)
data_for_curv_plot <- data.frame(x = x_vector[1:(length(y_vector_curv_scaled))], y = y_vector_curv_scaled)
# 3. Creazione del grafico usando i NUOVI dataframe
final_plot <- ggplot(data_for_func_plot, aes(x = x, y = y)) +
geom_line(aes(color = "Funzione m(x)"), linewidth = 1.1) +
geom_line(data = data_for_curv_plot, aes(x = x, y = y, color = "Curvatura Riscalata"), linetype = "dashed", linewidth = 1.1) +
labs(
title = "Funzione m(x) e la sua Curvatura (corretto)",
x = "X",
y = "Valore",
color = "Legenda"
) +
scale_color_manual(values = c("Funzione m(x)" = "blue", "Curvatura Riscalata" = "red")) +
theme_minimal() +
theme(legend.position = "bottom")
# 4. Stampa del grafico
print(final_plot)
